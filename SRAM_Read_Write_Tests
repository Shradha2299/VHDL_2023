library ieee;
use ieee.std_logic_1164.all;
use ieee.std_logic_arith.all;
use ieee.std_logic_unsigned.all;

entity SRAM is
port
(
rst, clk    : in std_logic;
wr_cmd, rd_cmd, chk_cmd, done, proceed    : out std_logic;
write_completed, read_completed, check_completed    : out std_logic;
ce, we, oe  : out std_logic;
pass_mon    : out std_logic;
a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12  : out std_logic;
data_in     : out std_logic_vector(7 downto 0);
data_out    : in std_logic_vector(7 downto 0);
fail        : out std_logic_vector(7 downto 0);
)
end SRAM;

architecture arc of SRAM is
type state_values is (idle, write_en, write_dis, write_comp, read_en, read_dis, check_wait, pass_fail);
signal pres_state, next_state: state_values;
signal data_reg: std_logic_vector(7 downto 0);
signal fail_cnt: std_logic_vector(13 downto 0);
signal adr_cnt, adr_ch, addr: std_logic_vector(12 downto 0);
signal addr_s: std_logic;

begin
--RESET
Reset_check: process(rst, clk)
begin
  if (rst = '0') then
    pres_state <= idle;
  elsif (clk'event and clk = '1') then
    pres_state <= next_state;
  end if;
end process Reser_check;

--FSM COMBINATIONAL BLOCK
--State Transition

fsm_trstn: process(rst, pres_state, adr_ch, wr_cmd, rd_cmd, chk_cmd, done, proceed)
begin
  case pres_state is
    when idle =>
      if(wr_cmd = '1') then
        next_state <= write_en;
      elsif(rd_cmd = '1') then
        next_state <= read_en;
      else
        next_state <= idle;
      end if;

    when wrtie_en =>
      if adr_ch = "1111111111111" then
        next_state <= write_comp;
      else
        next_state <= write_dis;
      end if;

    when write_dis =>
      next_state <= write_en;

    when write_comp =>
      if proceed = '1' then
        next_state <= idle;
      else 
        next_state <= write_comp;
      end if;

    when read_dis =>
      if adr_ch = "1111111111111" then
        next_state <= check_wait;
      else
        next_state <= read_en;
      end if;

    when read_en =>
      next_state <= read_dis;

    when check_wait =>
      if chk_cmd = '1' then
        next_state <= pass_fail;
      else 
        next_state <= check_wait;
      end if;

    when pass_fail =>
      if done = '1' then
        next_state <= idle
      else
        next_state <= pass_fail;
      end if;

    when others =>
      next_state <= idle;
  end case;
end process fem_trstn;

fsm_outputs: process(pres_state, adr_ch, data_out)
begin
  case pres_state is
    when idle =>
      we = '1';
      ce = '1';
      oe = '1';
      data_in <= "00000000";
      pass_mon <= '0';
      fail_cnt <= "00000000000000";
      data_reg <= "00000000";
      addr_s <= '1';
      write_completed <= '0';
      read_completed <= '0';
      check_completed <= '0';

    when write_en =>
      we = '1';
      ce = '0';
      oe = '1';
      data_in <= "01011010";                --5Ah
      pass_mon <= '0';
      fail_cnt <= "00000000000000";
      addr_s <= '1';
      write_completed <= '0';
      read_completed <= '0';
      check_completed <= '0';

    when write_dis =>
      we = '0';
      ce = '0';
      oe = '1';
      data_in <= "01011010";
      addr_s <= '1';

    when write_comp =>
      we = '1';
      ce = '1';
      oe = '1';
      data_in <= "00000000";
      addr_s <= '1';
      write_completed <= '1';
      read_completed <= '0';
      check_completed <= '0';      

      
